<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Filtering Edge Cases - cograph</title>
    <style>
        :root {
            --primary: #003355;
            --secondary: #4A90D9;
            --success: #2E7D32;
            --warning: #F57F17;
            --danger: #C62828;
            --light: #F5F5F5;
            --border: #E0E0E0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }

        h1 {
            color: var(--primary);
            border-bottom: 3px solid var(--secondary);
            padding-bottom: 10px;
        }

        h2 {
            color: var(--primary);
            margin-top: 40px;
            border-left: 4px solid var(--secondary);
            padding-left: 12px;
        }

        h3 {
            color: #444;
            margin-top: 25px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.95em;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid var(--border);
        }

        th {
            background: var(--primary);
            color: white;
        }

        tr:nth-child(even) {
            background: var(--light);
        }

        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            line-height: 1.4;
        }

        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .badge-pass { background: #E8F5E9; color: var(--success); }
        .badge-warn { background: #FFF8E1; color: var(--warning); }
        .badge-fail { background: #FFEBEE; color: var(--danger); }

        .warning-box {
            background: #FFF3E0;
            border-left: 4px solid #FF9800;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }

        .info-box {
            background: #E3F2FD;
            border-left: 4px solid var(--secondary);
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }

        .success-box {
            background: #E8F5E9;
            border-left: 4px solid var(--success);
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 4px 4px 0;
        }

        .category-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #FAFAFA;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .category-stats {
            font-size: 0.9em;
            color: #666;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .summary-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }

        .summary-card .number {
            font-size: 2.5em;
            font-weight: bold;
            color: var(--primary);
        }

        .summary-card .label {
            color: #666;
            font-size: 0.9em;
        }

        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <h1>Network Filtering Edge Cases</h1>
    <p>
        Comprehensive documentation of edge cases for <code>filter_nodes()</code> and
        <code>filter_edges()</code> functions in the cograph package. This investigation
        identifies scenarios that could break or produce unexpected results.
    </p>

    <div class="summary-grid">
        <div class="summary-card">
            <div class="number">56</div>
            <div class="label">Total Scenarios Tested</div>
        </div>
        <div class="summary-card">
            <div class="number" style="color: var(--success);">44</div>
            <div class="label">Pass (Expected)</div>
        </div>
        <div class="summary-card">
            <div class="number" style="color: var(--warning);">10</div>
            <div class="label">Warn (Expected)</div>
        </div>
        <div class="summary-card">
            <div class="number" style="color: var(--danger);">2</div>
            <div class="label">Fail (Known Limitation)</div>
        </div>
    </div>

    <h2>Executive Summary</h2>

    <div class="success-box">
        <strong>All 56 scenarios behaved as expected.</strong> The filter functions are robust
        and handle most edge cases gracefully with appropriate warnings.
    </div>

    <h3>Key Findings</h3>
    <ul>
        <li><strong>Empty results are handled gracefully</strong> - Functions issue warnings when
            filtering removes all nodes or edges, but do not crash.</li>
        <li><strong>Format preservation works</strong> - <code>keep_format = TRUE</code> correctly
            returns the input type (matrix, igraph, etc.)</li>
        <li><strong>Large networks perform well</strong> - 2000+ node networks filter in under 1 second</li>
        <li><strong>Special characters in labels work</strong> - Unicode, spaces, slashes all handled correctly</li>
    </ul>

    <h3>Known Limitations</h3>
    <div class="warning-box">
        <strong>Two scenarios have known limitations due to igraph's requirements:</strong>
        <ol>
            <li><strong>Negative weights</strong> - <code>filter_nodes()</code> computes betweenness centrality,
                which requires positive weights in igraph. Networks with negative weights will cause an error.</li>
            <li><strong>0×0 empty matrices</strong> - Cannot create a cograph_network from a 0×0 matrix.</li>
        </ol>
    </div>

    <h2>Test Categories</h2>

    <div class="category-section">
        <div class="category-header">
            <h3>1. Empty/Minimal Networks</h3>
            <span class="category-stats">5/5 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Description</th>
                <th>Result</th>
                <th>Notes</th>
            </tr>
            <tr>
                <td>1.1 Filter to 0 nodes</td>
                <td><code>filter_nodes(x, degree > 1000)</code></td>
                <td><span class="badge badge-warn">WARN</span></td>
                <td>Issues warning about empty result</td>
            </tr>
            <tr>
                <td>1.2 Single node remaining</td>
                <td>Keep only one node</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Works correctly, 0 edges</td>
            </tr>
            <tr>
                <td>1.3 Filter to 0 edges</td>
                <td><code>filter_edges(x, weight > 100)</code></td>
                <td><span class="badge badge-warn">WARN</span></td>
                <td>Issues warning about removed edges</td>
            </tr>
            <tr>
                <td>1.4 Empty input (0×0)</td>
                <td><code>as_cograph(matrix(0, 0, 0))</code></td>
                <td><span class="badge badge-fail">FAIL</span></td>
                <td>Known limitation - cannot construct</td>
            </tr>
            <tr>
                <td>1.5 Two nodes → one</td>
                <td>Filter 2-node network to 1</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Works correctly</td>
            </tr>
        </table>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>2. Sparse Networks</h3>
            <span class="category-stats">4/4 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Description</th>
                <th>Result</th>
            </tr>
            <tr>
                <td>2.1 Very sparse (density < 0.05)</td>
                <td>20 nodes, ~5% density</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>2.2 Tree structure (BA m=1)</td>
                <td>Scale-free tree</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>2.3 Disconnected components</td>
                <td>Two separate cliques</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>2.4 Single edge network</td>
                <td>Only one edge exists</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
        </table>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>3. Dense Networks</h3>
            <span class="category-stats">3/3 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Description</th>
                <th>Result</th>
            </tr>
            <tr>
                <td>3.1 Complete graph</td>
                <td>All nodes connected</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>3.2 High density by median</td>
                <td>80% density, filter by median weight</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>3.3 Diagonal-only (self-loops)</td>
                <td>Only diagonal has values</td>
                <td><span class="badge badge-warn">WARN</span></td>
            </tr>
        </table>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>4. Special Structures</h3>
            <span class="category-stats">4/4 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Description</th>
                <th>Result</th>
                <th>Notes</th>
            </tr>
            <tr>
                <td>4.1 Star network</td>
                <td><code>filter_nodes(x, degree > 1)</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Only hub remains</td>
            </tr>
            <tr>
                <td>4.2 Ring network</td>
                <td><code>filter_nodes(x, degree > 2)</code></td>
                <td><span class="badge badge-warn">WARN</span></td>
                <td>All nodes removed (all have degree 2)</td>
            </tr>
            <tr>
                <td>4.3 Path network</td>
                <td>Filter endpoints</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Endpoints removed correctly</td>
            </tr>
            <tr>
                <td>4.4 Bipartite structure</td>
                <td>Filter one partition</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Works correctly</td>
            </tr>
        </table>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>5. Edge Weight Distributions</h3>
            <span class="category-stats">6/6 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Description</th>
                <th>Result</th>
                <th>Notes</th>
            </tr>
            <tr>
                <td>5.1 Uniform weights</td>
                <td>All weights = 1, filter > 1</td>
                <td><span class="badge badge-warn">WARN</span></td>
                <td>All edges removed</td>
            </tr>
            <tr>
                <td>5.2 Negative weights</td>
                <td>Range [-1, 1]</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Edge filter works</td>
            </tr>
            <tr>
                <td>5.3 NA weights</td>
                <td>Some weights are NA</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>NAs handled in filter</td>
            </tr>
            <tr>
                <td>5.4 Inf weights</td>
                <td>Some weights are Inf</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Inf comparison works</td>
            </tr>
            <tr>
                <td>5.5 Zero weights</td>
                <td>Some weights are 0</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Zero = no edge handled</td>
            </tr>
            <tr>
                <td>5.6 Very small weights</td>
                <td>Near-zero (1e-10)</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Precision maintained</td>
            </tr>
        </table>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>6. Node Label Issues</h3>
            <span class="category-stats">6/6 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Test</th>
                <th>Result</th>
            </tr>
            <tr>
                <td>6.1 Duplicate labels</td>
                <td><code>c("A", "A", "B", "C", "D")</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>6.2 Empty string labels</td>
                <td><code>c("", "B", "C", ...)</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>6.3 NA labels</td>
                <td><code>c(NA, "B", "C", ...)</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>6.4 Numeric labels</td>
                <td><code>c("1", "2", "3", ...)</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>6.5 Special characters</td>
                <td><code>c("A/B", "C D", "E.F", ...)</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>6.6 Unicode labels</td>
                <td><code>c("α", "β", "γ", ...)</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
        </table>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>7. Large Networks</h3>
            <span class="category-stats">3/3 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Size</th>
                <th>Filter</th>
                <th>Time</th>
                <th>Result</th>
            </tr>
            <tr>
                <td>7.1 PageRank filter</td>
                <td>1000 nodes</td>
                <td><code>pagerank > 0.005</code></td>
                <td>~0.13s</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>7.2 Edge filter</td>
                <td>500 nodes, dense</td>
                <td><code>weight > 0.7</code></td>
                <td>~0.01s</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>7.3 Degree filter</td>
                <td>2000 nodes, sparse</td>
                <td><code>degree >= 5</code></td>
                <td>~0.38s</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
        </table>

        <div class="info-box">
            Performance is excellent even for large networks. The bottleneck is typically
            centrality computation (PageRank, betweenness), not the filtering itself.
        </div>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>8. Directed vs Undirected</h3>
            <span class="category-stats">4/4 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Description</th>
                <th>Result</th>
                <th>Notes</th>
            </tr>
            <tr>
                <td>8.1 Indegree filter</td>
                <td>Directed network</td>
                <td><span class="badge badge-warn">WARN</span></td>
                <td>DAG triggers eigenvector warning</td>
            </tr>
            <tr>
                <td>8.2 Outdegree filter</td>
                <td>Directed network</td>
                <td><span class="badge badge-warn">WARN</span></td>
                <td>DAG triggers eigenvector warning</td>
            </tr>
            <tr>
                <td>8.3 Asymmetric weights</td>
                <td>Different A→B vs B→A</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Direction preserved</td>
            </tr>
            <tr>
                <td>8.4 Force undirected</td>
                <td><code>directed = FALSE</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Conversion works</td>
            </tr>
        </table>

        <div class="warning-box">
            <strong>Note:</strong> Directed acyclic graphs (DAGs) cause igraph to issue a warning
            when computing eigenvector centrality. This is informational, not an error.
        </div>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>9. Chained Filters</h3>
            <span class="category-stats">5/5 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Chain</th>
                <th>Result</th>
            </tr>
            <tr>
                <td>9.1 Edge → Node</td>
                <td><code>filter_edges() |> filter_nodes()</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>9.2 Node → Edge</td>
                <td><code>filter_nodes() |> filter_edges()</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>9.3 Multiple node filters</td>
                <td><code>filter_nodes() |> filter_nodes()</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>9.4 Progressive to empty</td>
                <td>Multiple increasingly strict filters</td>
                <td><span class="badge badge-warn">WARN</span></td>
            </tr>
            <tr>
                <td>9.5 Complex compound</td>
                <td><code>degree >= 2 & betweenness > 0</code></td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
        </table>

        <div class="info-box">
            Filter order matters! <code>filter_edges()</code> then <code>filter_nodes()</code>
            may produce different results than the reverse order.
        </div>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>10. Format Conversion</h3>
            <span class="category-stats">5/5 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Input</th>
                <th>keep_format</th>
                <th>Output</th>
                <th>Result</th>
            </tr>
            <tr>
                <td>matrix</td>
                <td>TRUE</td>
                <td>matrix</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>matrix</td>
                <td>TRUE (empty)</td>
                <td>0×0 matrix</td>
                <td><span class="badge badge-warn">WARN</span></td>
            </tr>
            <tr>
                <td>igraph</td>
                <td>TRUE</td>
                <td>igraph</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>igraph</td>
                <td>TRUE (1 node)</td>
                <td>igraph</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>cograph_network</td>
                <td>FALSE</td>
                <td>cograph_network</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
        </table>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>11. Centrality Edge Cases</h3>
            <span class="category-stats">5/5 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>Description</th>
                <th>Result</th>
                <th>Notes</th>
            </tr>
            <tr>
                <td>11.1 Eigenvector on disconnected</td>
                <td>Two separate components</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Handled gracefully</td>
            </tr>
            <tr>
                <td>11.2 Closeness on disconnected</td>
                <td>May produce NA/Inf</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>NA handling works</td>
            </tr>
            <tr>
                <td>11.3 Betweenness on tree</td>
                <td>Many zero values</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Works correctly</td>
            </tr>
            <tr>
                <td>11.4 Hub/authority undirected</td>
                <td>HITS on undirected graph</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Symmetric results</td>
            </tr>
            <tr>
                <td>11.5 Negative weights</td>
                <td>Betweenness requires positive</td>
                <td><span class="badge badge-fail">FAIL</span></td>
                <td><strong>Known limitation</strong></td>
            </tr>
        </table>

        <div class="warning-box">
            <strong>Known Limitation:</strong> <code>filter_nodes()</code> computes all centrality
            measures including betweenness, which requires positive edge weights in igraph.
            Networks with negative weights will cause an error.
            <br><br>
            <strong>Workaround:</strong> Use <code>filter_edges(x, weight >= 0)</code> first, or
            transform weights with <code>abs(weight)</code>.
        </div>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>12. Keep Isolates Option</h3>
            <span class="category-stats">2/2 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Scenario</th>
                <th>.keep_isolates</th>
                <th>Result</th>
                <th>Behavior</th>
            </tr>
            <tr>
                <td>After strict edge filter</td>
                <td>TRUE</td>
                <td><span class="badge badge-warn">WARN</span></td>
                <td>All 5 nodes kept, 0 edges</td>
            </tr>
            <tr>
                <td>After strict edge filter</td>
                <td>FALSE (default)</td>
                <td><span class="badge badge-pass">PASS</span></td>
                <td>Only connected nodes kept</td>
            </tr>
        </table>
    </div>

    <div class="category-section">
        <div class="category-header">
            <h3>13. Saqrlab Network Models</h3>
            <span class="category-stats">4/4 expected outcomes</span>
        </div>

        <table>
            <tr>
                <th>Model</th>
                <th>Parameters</th>
                <th>Result</th>
            </tr>
            <tr>
                <td>Erdos-Renyi (ER)</td>
                <td>n=50, p=0.1</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>Barabasi-Albert (BA)</td>
                <td>n=100, m=2</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>Watts-Strogatz (WS)</td>
                <td>n=50, nei=4, p_rewire=0.1</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
            <tr>
                <td>Stochastic Block Model (SBM)</td>
                <td>n=60, 2 blocks</td>
                <td><span class="badge badge-pass">PASS</span></td>
            </tr>
        </table>
    </div>

    <h2>Best Practices</h2>

    <h3>1. Check for empty results</h3>
    <pre><code>result <- filter_nodes(x, degree > 10)
if (n_nodes(result) == 0) {
  warning("Filter too strict - no nodes remain")
}</code></pre>

    <h3>2. Use positive weights with filter_nodes()</h3>
    <pre><code># If your network has negative weights, transform first:
x_pos <- filter_edges(x, weight >= 0)
result <- filter_nodes(x_pos, betweenness > 100)

# Or use degree/strength only (doesn't require betweenness):
result <- filter_edges(x, weight > 0) |>
  filter_nodes(degree >= 3)</code></pre>

    <h3>3. Preserve format when needed</h3>
    <pre><code># Get back the same type you put in
mat_filtered <- filter_edges(mat, weight > 0.5, keep_format = TRUE)
stopifnot(is.matrix(mat_filtered))</code></pre>

    <h3>4. Consider filter order</h3>
    <pre><code># Edge filter then node filter: remove weak edges first
result1 <- x |>
  filter_edges(weight > 0.3) |>
  filter_nodes(degree >= 2)

# Node filter then edge filter: keep only connected high-degree nodes
result2 <- x |>
  filter_nodes(degree >= 2) |>
  filter_edges(weight > 0.3)

# These may produce different results!</code></pre>

    <h2>Running the Tests</h2>
    <pre><code># Run the full test suite
Rscript validation/test_filter_edge_cases.R

# Load results
results <- readRDS("validation/results_filter_edge_cases.rds")
View(results)</code></pre>

    <footer>
        <p>
            Generated by cograph validation suite |
            Last updated: <span id="date"></span>
        </p>
        <script>document.getElementById('date').textContent = new Date().toLocaleDateString();</script>
    </footer>
</body>
</html>
