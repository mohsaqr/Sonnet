% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/network-utils.R
\name{select_edges}
\alias{select_edges}
\title{Select Edges with Lazy Computation}
\usage{
select_edges(
  x,
  ...,
  top = NULL,
  by = "weight",
  involving = NULL,
  between = NULL,
  bridges_only = FALSE,
  mutual_only = FALSE,
  community = "louvain",
  .keep_isolates = FALSE,
  keep_format = FALSE,
  directed = NULL
)
}
\arguments{
\item{x}{Network input: cograph_network, matrix, igraph, network, or tna object.}

\item{...}{Filter expressions using edge columns or computed metrics.
Available variables:
\describe{
\item{Edge columns}{\code{from}, \code{to}, \code{weight}, plus any custom}
\item{Computed metrics}{\code{abs_weight}, \code{from_degree}, \code{to_degree},
\code{from_strength}, \code{to_strength}, \code{edge_betweenness},
\code{is_bridge}, \code{is_mutual}, \code{same_community}}
}}

\item{top}{Integer. Select top N edges by a metric.}

\item{by}{Character. Metric for top selection. Default \code{"weight"}.
Options: \code{"weight"}, \code{"abs_weight"}, \code{"edge_betweenness"}.}

\item{involving}{Character or integer. Select edges involving these nodes
(by name or index). An edge is selected if either endpoint matches.}

\item{between}{List of two character/integer vectors. Select edges between
two node sets. Example: \code{between = list(c("A", "B"), c("C", "D"))}.}

\item{bridges_only}{Logical. Select only bridge edges (edges whose removal
disconnects the graph). Default FALSE.}

\item{mutual_only}{Logical. For directed networks, select only mutual
(reciprocated) edges. Default FALSE.}

\item{community}{Character. Community detection method for \code{same_community}
variable. One of \code{"louvain"}, \code{"walktrap"}, \code{"fast_greedy"},
\code{"label_prop"}, \code{"infomap"}, \code{"leiden"}. Default \code{"louvain"}.}

\item{.keep_isolates}{Logical. Keep nodes with no remaining edges? Default FALSE.}

\item{keep_format}{Logical. If TRUE, return the same format as input.
Default FALSE returns cograph_network.}

\item{directed}{Logical or NULL. If NULL (default), auto-detect.}
}
\value{
A cograph_network object with selected edges. If \code{keep_format = TRUE},
returns the same type as input.
}
\description{
A powerful edge selection function with lazy computation (only computes
metrics actually referenced), multiple selection modes, and structural
awareness (bridges, communities, reciprocity).
}
\details{
Selection modes are combined with AND logic:
\itemize{
\item \code{select_edges(x, top = 10, involving = "A")} selects
top 10 edges \strong{among those involving node A}
\item All criteria must be satisfied for an edge to be selected
}

Edge metrics are computed lazily - only those actually referenced in
expressions or required by selection modes are computed.
}
\examples{
adj <- matrix(c(0, .5, .8, 0,
                .5, 0, .3, .6,
                .8, .3, 0, .4,
                 0, .6, .4, 0), 4, 4, byrow = TRUE)
rownames(adj) <- colnames(adj) <- c("A", "B", "C", "D")

# Expression-based (lazy - only computes what's needed)
select_edges(adj, weight > 0.5)
select_edges(adj, abs_weight > 0.4)

# Top N edges by weight
select_edges(adj, top = 3)
select_edges(adj, top = 3, by = "edge_betweenness")

# Edges involving specific nodes
select_edges(adj, involving = "A")
select_edges(adj, involving = c("A", "B"))

# Edges between two node sets
select_edges(adj, between = list(c("A", "B"), c("C", "D")))

# Bridge edges only
select_edges(adj, bridges_only = TRUE)

# Combined: top 3 edges involving A
select_edges(adj, involving = "A", top = 3)

# Using endpoint degrees
select_edges(adj, from_degree >= 3 | to_degree >= 3)

# Within-community edges
select_edges(adj, same_community)
}
\seealso{
\code{\link{filter_edges}}, \code{\link{select_nodes}},
\code{\link{select_bridges}}, \code{\link{select_top_edges}}
}
