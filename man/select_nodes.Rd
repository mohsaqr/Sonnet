% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/network-utils.R
\name{select_nodes}
\alias{select_nodes}
\title{Select Nodes with Lazy Centrality Computation}
\usage{
select_nodes(
  x,
  ...,
  name = NULL,
  index = NULL,
  top = NULL,
  by = "degree",
  neighbors_of = NULL,
  order = 1L,
  component = NULL,
  .keep_edges = c("internal", "none"),
  keep_format = FALSE,
  directed = NULL
)
}
\arguments{
\item{x}{Network input: cograph_network, matrix, igraph, network, or tna object.}

\item{...}{Filter expressions using node columns, centrality measures, or
global context variables. Centrality measures are computed lazily (only
those actually referenced). Available variables:
\describe{
\item{Node columns}{All columns in the nodes dataframe: \code{id}, \code{label},
\code{name}, \code{x}, \code{y}, \code{inits}, \code{color}, plus any custom}
\item{Centrality measures}{\code{degree}, \code{indegree}, \code{outdegree},
\code{strength}, \code{instrength}, \code{outstrength}, \code{betweenness},
\code{closeness}, \code{eigenvector}, \code{pagerank}, \code{hub},
\code{authority}, \code{coreness}}
\item{Global context}{\code{component}, \code{component_size},
\code{is_largest_component}, \code{neighborhood_size}, \code{k_core},
\code{is_articulation}, \code{is_bridge_endpoint}}
}}

\item{name}{Character vector. Select nodes by name/label.}

\item{index}{Integer vector. Select nodes by index (1-based).}

\item{top}{Integer. Select top N nodes by centrality measure.}

\item{by}{Character. Centrality measure for top selection. Default \code{"degree"}.}

\item{neighbors_of}{Character or integer. Select neighbors of these nodes
(by name or index).}

\item{order}{Integer. Neighborhood order (1 = direct neighbors, 2 = neighbors
of neighbors, etc.). Default 1.}

\item{component}{Selection mode for connected components:
\describe{
\item{\code{"largest"}}{Select nodes in the largest connected component}
\item{Integer}{Select nodes in component with this ID}
\item{Character}{Select component containing node with this name}
}}

\item{.keep_edges}{How to handle edges. One of:
\describe{
\item{\code{"internal"}}{(default) Keep only edges between remaining nodes}
\item{\code{"none"}}{Remove all edges}
}}

\item{keep_format}{Logical. If TRUE, return the same format as input.
Default FALSE returns cograph_network.}

\item{directed}{Logical or NULL. If NULL (default), auto-detect.}
}
\value{
A cograph_network object with selected nodes. If \code{keep_format = TRUE},
returns the same type as input.
}
\description{
A more nuanced node selection function that improves upon \code{filter_nodes()}
with lazy centrality computation (only computes measures actually referenced),
multiple selection modes, and global context variables for structural awareness.
}
\details{
Selection modes are combined with AND logic (like tidygraph/dplyr):
\itemize{
\item \code{select_nodes(x, top = 10, component = "largest")} selects
top 10 nodes \strong{within} the largest component
\item All criteria must be satisfied for a node to be selected
}

Centrality measures are computed lazily - only measures actually referenced
in expressions or the \code{by} parameter are computed. This makes
\code{select_nodes()} faster than \code{filter_nodes()} for large networks.

For networks with negative edge weights, \code{betweenness} and \code{closeness}
will return NA with a warning (igraph cannot compute these with negative weights).
}
\examples{
adj <- matrix(c(0, .5, .8, 0,
                .5, 0, .3, .6,
                .8, .3, 0, .4,
                 0, .6, .4, 0), 4, 4, byrow = TRUE)
rownames(adj) <- colnames(adj) <- c("A", "B", "C", "D")

# Lazy - only computes degree
select_nodes(adj, degree >= 3)

# Global context - computes component info
select_nodes(adj, is_largest_component & degree >= 2)

# By name
select_nodes(adj, name = c("A", "B", "C"))

# Top 2 by PageRank
select_nodes(adj, top = 2, by = "pagerank")

# Neighborhood of "A" up to 2 hops
select_nodes(adj, neighbors_of = "A", order = 2)

# Largest connected component
select_nodes(adj, component = "largest")

# Combined: top 2 in largest component
select_nodes(adj, component = "largest", top = 2, by = "degree")

# Articulation points with high degree
# select_nodes(adj, is_articulation & degree >= 2)
}
\seealso{
\code{\link{filter_nodes}}, \code{\link{select_neighbors}},
\code{\link{select_component}}, \code{\link{select_top}}
}
