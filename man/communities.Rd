% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/communities.R
\name{communities}
\alias{communities}
\title{Community Detection}
\usage{
communities(
  x,
  method = c("louvain", "leiden", "fast_greedy", "walktrap", "infomap", "label_prop",
    "edge_betweenness", "leading_eigen", "spinglass", "optimal", "fluid"),
  weights = NULL,
  resolution = 1,
  directed = NULL,
  ...
)
}
\arguments{
\item{x}{Network input: matrix, igraph, network, cograph_network, or tna object}

\item{method}{Community detection algorithm. One of:
\itemize{
\item \code{"louvain"} - Louvain modularity optimization (default, fast)
\item \code{"leiden"} - Leiden algorithm (improved Louvain)
\item \code{"fast_greedy"} - Fast greedy modularity optimization
\item \code{"walktrap"} - Random walk-based detection
\item \code{"infomap"} - Information theoretic approach
\item \code{"label_prop"} - Label propagation (very fast)
\item \code{"edge_betweenness"} - Girvan-Newman algorithm
\item \code{"leading_eigen"} - Leading eigenvector method
\item \code{"spinglass"} - Spinglass simulation
\item \code{"optimal"} - Exact modularity optimization (slow)
\item \code{"fluid"} - Fluid communities algorithm
}}

\item{weights}{Edge weights. If NULL, uses edge weights from the network
if available, otherwise unweighted. Set to NA for explicitly unweighted.}

\item{resolution}{Resolution parameter for modularity-based methods
(louvain, leiden). Higher values yield more communities. Default 1.}

\item{directed}{Logical; whether to treat the network as directed.
Default NULL (auto-detect).}

\item{...}{Additional parameters passed to the specific algorithm.
See individual functions for details.}
}
\value{
A \code{cograph_communities} object (extends igraph's communities class)
with components:
\describe{
\item{membership}{Integer vector of community assignments}
\item{modularity}{Modularity score of the partition}
\item{algorithm}{Name of the algorithm used
\item{names}{Node names if available}
\item{vcount}{Number of nodes}
}
}
\description{
Detects communities/clusters in networks using various algorithms.
Provides a unified interface to igraph's community detection functions
with full parameter exposure.
}
\details{
\strong{Algorithm Selection Guide:}

\tabular{lll}{
Algorithm \tab Best For \tab Time Complexity \cr
louvain \tab Large networks, general use \tab O(n log n) \cr
leiden \tab Large networks, better quality than louvain \tab O(n log n) \cr
fast_greedy \tab Medium networks \tab O(n² log n) \cr
walktrap \tab Networks with clear community structure \tab O(n² log n) \cr
infomap \tab Directed networks, flow-based \tab O(E) \cr
label_prop \tab Very large networks, speed critical \tab O(E) \cr
edge_betweenness \tab Small networks, hierarchical \tab O(E² n) \cr
leading_eigen \tab Networks with dominant structure \tab O(n²) \cr
spinglass \tab Small networks, allows negative weights \tab O(n³) \cr
optimal \tab Tiny networks only (<50 nodes) \tab NP-hard \cr
fluid \tab When k is known \tab O(E k) \cr
}
}
\examples{
# Create a network with community structure
if (requireNamespace("igraph", quietly = TRUE)) {
  g <- igraph::make_graph("Zachary")

  # Default (Louvain)
  comm <- communities(g)
  print(comm)

  # Leiden with higher resolution
  comm2 <- communities(g, method = "leiden", resolution = 1.5)

  # Compare modularity
  cat("Louvain modularity:", modularity(comm), "\n")
  cat("Leiden modularity:", modularity(comm2), "\n")
}
}
\seealso{
\code{\link{community_louvain}}, \code{\link{community_leiden}},
\code{\link{community_fast_greedy}}, \code{\link{community_walktrap}},
\code{\link{community_infomap}}, \code{\link{community_label_prop}},
\code{\link{community_edge_betweenness}}, \code{\link{community_leading_eigen}},
\code{\link{community_spinglass}}, \code{\link{community_optimal}},
\code{\link{community_fluid}}
}
