% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/motifs.R
\name{extract_triads}
\alias{extract_triads}
\title{Extract Triads with Node Labels}
\usage{
extract_triads(
  x,
  type = NULL,
  involving = NULL,
  threshold = 0,
  min_total = 5,
  directed = NULL
)
}
\arguments{
\item{x}{A matrix, igraph object, tna, or cograph_network}

\item{type}{Character vector of MAN codes to filter by (e.g., "030T", "030C").
Default NULL returns all types.}

\item{involving}{Character vector of node labels. Only return triads
involving at least one of these nodes. Default NULL returns all triads.}

\item{threshold}{Minimum edge weight for an edge to be considered present.
Type is determined by edges with weight > threshold. Default 0.}

\item{min_total}{Minimum total weight across all 6 edges. Excludes trivial
triads with low overall activity. Default 5.}

\item{directed}{Logical. Treat network as directed? Default auto-detected.}
}
\value{
A data frame with columns:
\describe{
\item{A, B, C}{Node labels for the three nodes in the triad}
\item{type}{MAN code (003, 012, ..., 300)}
\item{weight_AB, weight_BA, weight_AC, weight_CA, weight_BC, weight_CB}{
Edge weights (frequencies) for all 6 possible directed edges}
\item{total_weight}{Sum of all 6 edge weights}
}
}
\description{
Extract all triads from a network, preserving node labels. This allows
users to see which specific node combinations form each motif pattern.
}
\details{
This function complements \code{\link[=motif_census]{motif_census()}} by showing the actual node
combinations that form each motif pattern. A typical workflow is:
\enumerate{
\item Use \code{motif_census()} to identify over/under-represented patterns
\item Use \code{extract_triads()} with \code{type} filter to see which nodes form those patterns
\item Sort by \code{total_weight} to find the strongest triads
}

\strong{Type vs Weight distinction:}
\itemize{
\item \strong{Type} is determined by edge presence (weight > threshold)
\item \strong{Weights} are the actual frequency counts, useful for ranking triads by strength
}
}
\examples{
# Create a frequency matrix
mat <- matrix(c(
  0, 3, 2, 0,
  0, 0, 5, 1,
  0, 0, 0, 4,
  2, 0, 0, 0
), 4, 4, byrow = TRUE)
rownames(mat) <- colnames(mat) <- c("Plan", "Execute", "Monitor", "Adapt")

net <- as_cograph(mat)

# Extract all triads
triads <- extract_triads(net)
head(triads)

# Filter by motif type (feed-forward loops only)
ff_loops <- extract_triads(net, type = "030T")

# Filter by node involvement
plan_triads <- extract_triads(net, involving = "Plan")

# Find strongest triads
triads <- extract_triads(net)
strongest <- triads[order(triads$total_weight, decreasing = TRUE), ]

}
\seealso{
\code{\link[=motif_census]{motif_census()}}, \code{\link[=triad_census]{triad_census()}}
}
